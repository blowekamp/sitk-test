<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Google Tag Manager -->
<script>
  (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push(
  {'gtm.start': new Date().getTime(),event:'gtm.js'}
  );var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-N38XC8T');
</script>
<!-- End Google Tag Manager -->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimpleITK: itk::simple::Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N38XC8T"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe>
</noscript>
<!-- End Google Tag Manager (noscript) -->
<script type="text/javascript" src="build_text.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SimpleITK
   &#160;<span id="projectnumber">unknown</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceitk.html">itk</a></li><li class="navelem"><a class="el" href="namespaceitk_1_1simple.html">simple</a></li><li class="navelem"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classitk_1_1simple_1_1Image-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">itk::simple::Image Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class for SimpleITK.  
 <a href="classitk_1_1simple_1_1Image.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for itk::simple::Image:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classitk_1_1simple_1_1Image__coll__graph.svg" width="231" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1simple_1_1Image_1_1AllocateMemberFunctionAddressor.html">AllocateMemberFunctionAddressor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5f3a8beb0170782f77853b044ddd02a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a5f3a8beb0170782f77853b044ddd02a4">Self</a> = <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a></td></tr>
<tr class="separator:a5f3a8beb0170782f77853b044ddd02a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa8a4757400c414e809d1767ee616bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#afa8a4757400c414e809d1767ee616bd0">CopyInformation</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;srcImage)</td></tr>
<tr class="memdesc:afa8a4757400c414e809d1767ee616bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy common meta-data from an image to this one.  <a href="classitk_1_1simple_1_1Image.html#afa8a4757400c414e809d1767ee616bd0">More...</a><br /></td></tr>
<tr class="separator:afa8a4757400c414e809d1767ee616bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c224f1f5173836258dbb983341a2f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#af5c224f1f5173836258dbb983341a2f9">EraseMetaData</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:af5c224f1f5173836258dbb983341a2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry from the meta-data dictionary.  <a href="classitk_1_1simple_1_1Image.html#af5c224f1f5173836258dbb983341a2f9">More...</a><br /></td></tr>
<tr class="separator:af5c224f1f5173836258dbb983341a2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393912859bda381a8b7b0ec79cfce4a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a393912859bda381a8b7b0ec79cfce4a1">EvaluateAtContinuousIndex</a> (const std::vector&lt; double &gt; &amp;index, <a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a> interp=<a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a>) const</td></tr>
<tr class="memdesc:a393912859bda381a8b7b0ec79cfce4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate pixel value at a continuous index.  <a href="classitk_1_1simple_1_1Image.html#a393912859bda381a8b7b0ec79cfce4a1">More...</a><br /></td></tr>
<tr class="separator:a393912859bda381a8b7b0ec79cfce4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f96579d0f3da2d1a3b48d4e1037fbc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aa2f96579d0f3da2d1a3b48d4e1037fbc">EvaluateAtPhysicalPoint</a> (const std::vector&lt; double &gt; &amp;point, <a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a> interp=<a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a>) const</td></tr>
<tr class="separator:aa2f96579d0f3da2d1a3b48d4e1037fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9d6f84e457f7f6e59665c26a02cd4e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a0e9d6f84e457f7f6e59665c26a02cd4e">GetDepth</a> () const</td></tr>
<tr class="separator:a0e9d6f84e457f7f6e59665c26a02cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43163c72ca1a49abf615b3dc71e01a36"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension</a> () const</td></tr>
<tr class="separator:a43163c72ca1a49abf615b3dc71e01a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a9572d84ae73623652bdc1ecb7cf2d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a88a9572d84ae73623652bdc1ecb7cf2d">GetHeight</a> () const</td></tr>
<tr class="separator:a88a9572d84ae73623652bdc1ecb7cf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43df17945f303feb16b4accf1b684515"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a43df17945f303feb16b4accf1b684515">GetMetaData</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a43df17945f303feb16b4accf1b684515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a meta-data dictionary entry as a string.  <a href="classitk_1_1simple_1_1Image.html#a43df17945f303feb16b4accf1b684515">More...</a><br /></td></tr>
<tr class="separator:a43df17945f303feb16b4accf1b684515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf9bbdb75a90784da8012286a8692eb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a4cf9bbdb75a90784da8012286a8692eb">GetMetaDataKeys</a> () const</td></tr>
<tr class="memdesc:a4cf9bbdb75a90784da8012286a8692eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector of keys in from the meta-data dictionary  <a href="classitk_1_1simple_1_1Image.html#a4cf9bbdb75a90784da8012286a8692eb">More...</a><br /></td></tr>
<tr class="separator:a4cf9bbdb75a90784da8012286a8692eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b4188222fc781607ab26c69fc5423"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#abb8b4188222fc781607ab26c69fc5423">GetNumberOfComponentsPerPixel</a> () const</td></tr>
<tr class="memdesc:abb8b4188222fc781607ab26c69fc5423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of components for each pixel.  <a href="classitk_1_1simple_1_1Image.html#abb8b4188222fc781607ab26c69fc5423">More...</a><br /></td></tr>
<tr class="separator:abb8b4188222fc781607ab26c69fc5423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584912065b5cc03923319b15bd9fc16e"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a584912065b5cc03923319b15bd9fc16e">GetNumberOfPixels</a> () const</td></tr>
<tr class="memdesc:a584912065b5cc03923319b15bd9fc16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of pixels in the image.  <a href="classitk_1_1simple_1_1Image.html#a584912065b5cc03923319b15bd9fc16e">More...</a><br /></td></tr>
<tr class="separator:a584912065b5cc03923319b15bd9fc16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780923bec6a71b14be35d81069f343f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a780923bec6a71b14be35d81069f343f6">GetPixelID</a> () const</td></tr>
<tr class="separator:a780923bec6a71b14be35d81069f343f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad195963d0b257560819b833b9cfe18d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ad195963d0b257560819b833b9cfe18d6">GetPixelIDTypeAsString</a> () const</td></tr>
<tr class="separator:ad195963d0b257560819b833b9cfe18d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c27e845c3327ae8cf133db1750fd18b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceitk_1_1simple.html#ae47036246a9a1312411ce2fc6d296d1d">PixelIDValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">GetPixelIDValue</a> () const</td></tr>
<tr class="separator:a3c27e845c3327ae8cf133db1750fd18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade45738b2c906a51f23532aa972f6169"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ade45738b2c906a51f23532aa972f6169">GetSize</a> () const</td></tr>
<tr class="separator:ade45738b2c906a51f23532aa972f6169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4705e6e3ad0dcec4a8230462af81c19"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#af4705e6e3ad0dcec4a8230462af81c19">GetSizeOfPixelComponent</a> () const</td></tr>
<tr class="memdesc:af4705e6e3ad0dcec4a8230462af81c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes per component of a pixel.  <a href="classitk_1_1simple_1_1Image.html#af4705e6e3ad0dcec4a8230462af81c19">More...</a><br /></td></tr>
<tr class="separator:af4705e6e3ad0dcec4a8230462af81c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9ca4a6cd1a0c77e8c5c713e447b3a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#af7b9ca4a6cd1a0c77e8c5c713e447b3a">GetWidth</a> () const</td></tr>
<tr class="separator:af7b9ca4a6cd1a0c77e8c5c713e447b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b869a842f2e7aeb75fbd0a84046cca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a38b869a842f2e7aeb75fbd0a84046cca">HasMetaDataKey</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a38b869a842f2e7aeb75fbd0a84046cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the meta-data dictionary for the existence of a key.  <a href="classitk_1_1simple_1_1Image.html#a38b869a842f2e7aeb75fbd0a84046cca">More...</a><br /></td></tr>
<tr class="separator:a38b869a842f2e7aeb75fbd0a84046cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a8055958ef17e5fd3602e68e28fcc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a42a8055958ef17e5fd3602e68e28fcc7">Image</a> ()</td></tr>
<tr class="memdesc:a42a8055958ef17e5fd3602e68e28fcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, creates an image of size 0.  <a href="classitk_1_1simple_1_1Image.html#a42a8055958ef17e5fd3602e68e28fcc7">More...</a><br /></td></tr>
<tr class="separator:a42a8055958ef17e5fd3602e68e28fcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a51dbe990dae1370afe39a65103527"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ae3a51dbe990dae1370afe39a65103527">Image</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:ae3a51dbe990dae1370afe39a65103527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92e6ec5a7b76f66671d14480906aef0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#af92e6ec5a7b76f66671d14480906aef0">Image</a> (<a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;img) noexcept</td></tr>
<tr class="memdesc:af92e6ec5a7b76f66671d14480906aef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor and assignment.  <a href="classitk_1_1simple_1_1Image.html#af92e6ec5a7b76f66671d14480906aef0">More...</a><br /></td></tr>
<tr class="separator:af92e6ec5a7b76f66671d14480906aef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5b1f66e3812a286b3e9f4ac8ed976f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aec5b1f66e3812a286b3e9f4ac8ed976f">IsUnique</a> () const</td></tr>
<tr class="memdesc:aec5b1f66e3812a286b3e9f4ac8ed976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no other SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> object refers to the same internal data structure.  <a href="classitk_1_1simple_1_1Image.html#aec5b1f66e3812a286b3e9f4ac8ed976f">More...</a><br /></td></tr>
<tr class="separator:aec5b1f66e3812a286b3e9f4ac8ed976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5066b75d324db414df1a34c4065d1c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ab5066b75d324db414df1a34c4065d1c9">MakeUnique</a> ()</td></tr>
<tr class="memdesc:ab5066b75d324db414df1a34c4065d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs actually coping if needed to make object unique.  <a href="classitk_1_1simple_1_1Image.html#ab5066b75d324db414df1a34c4065d1c9">More...</a><br /></td></tr>
<tr class="separator:ab5066b75d324db414df1a34c4065d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544257ed6b37d939c081af1c18753b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a544257ed6b37d939c081af1c18753b2c">operator=</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:a544257ed6b37d939c081af1c18753b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7c186de418cc97050e3ced622cf8c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#abd7c186de418cc97050e3ced622cf8c2">operator=</a> (<a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;img) noexcept</td></tr>
<tr class="separator:abd7c186de418cc97050e3ced622cf8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1663c39bf013511f30a632a6b4290d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1663c39bf013511f30a632a6b4290d83">SetMetaData</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr class="memdesc:a1663c39bf013511f30a632a6b4290d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an entry in the meta-data dictionary.  <a href="classitk_1_1simple_1_1Image.html#a1663c39bf013511f30a632a6b4290d83">More...</a><br /></td></tr>
<tr class="separator:a1663c39bf013511f30a632a6b4290d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c9fa1902dae8f984bda1bdeafa4a3c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a47c9fa1902dae8f984bda1bdeafa4a3c">ToString</a> () const</td></tr>
<tr class="separator:a47c9fa1902dae8f984bda1bdeafa4a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639da24d8df6d41989447d2ec95cb51d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a639da24d8df6d41989447d2ec95cb51d">TransformContinuousIndexToPhysicalPoint</a> (const std::vector&lt; double &gt; &amp;index) const</td></tr>
<tr class="separator:a639da24d8df6d41989447d2ec95cb51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c1a1ecaa5bd379d3132c7e95619aaa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a87c1a1ecaa5bd379d3132c7e95619aaa">TransformIndexToPhysicalPoint</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt; &amp;index) const</td></tr>
<tr class="separator:a87c1a1ecaa5bd379d3132c7e95619aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aa3f19b31f54ec9fc2846a29428adb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#af2aa3f19b31f54ec9fc2846a29428adb">TransformPhysicalPointToContinuousIndex</a> (const std::vector&lt; double &gt; &amp;point) const</td></tr>
<tr class="separator:af2aa3f19b31f54ec9fc2846a29428adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9474e4ded374c8350418fe5329187704"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a9474e4ded374c8350418fe5329187704">TransformPhysicalPointToIndex</a> (const std::vector&lt; double &gt; &amp;point) const</td></tr>
<tr class="separator:a9474e4ded374c8350418fe5329187704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef33af720d7ce65533fbb10b2b53f51"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#adef33af720d7ce65533fbb10b2b53f51">~Image</a> ()</td></tr>
<tr class="separator:adef33af720d7ce65533fbb10b2b53f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a14b96e088ce9f8d72f3c71663b376476"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a14b96e088ce9f8d72f3c71663b376476">Image</a> (unsigned int width, unsigned int height, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum)</td></tr>
<tr class="memdesc:a14b96e088ce9f8d72f3c71663b376476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified.  <a href="classitk_1_1simple_1_1Image.html#a14b96e088ce9f8d72f3c71663b376476">More...</a><br /></td></tr>
<tr class="separator:a14b96e088ce9f8d72f3c71663b376476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f5f36459b477581b3d7f0c99d1f9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a619f5f36459b477581b3d7f0c99d1f9c">Image</a> (unsigned int width, unsigned int height, unsigned int depth, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum)</td></tr>
<tr class="memdesc:a619f5f36459b477581b3d7f0c99d1f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified.  <a href="classitk_1_1simple_1_1Image.html#a619f5f36459b477581b3d7f0c99d1f9c">More...</a><br /></td></tr>
<tr class="separator:a619f5f36459b477581b3d7f0c99d1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc77be35235acbc1b67e60e7670194c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#affc77be35235acbc1b67e60e7670194c">Image</a> (const std::vector&lt; unsigned int &gt; &amp;size, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum, unsigned int numberOfComponents=0)</td></tr>
<tr class="memdesc:affc77be35235acbc1b67e60e7670194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified.  <a href="classitk_1_1simple_1_1Image.html#affc77be35235acbc1b67e60e7670194c">More...</a><br /></td></tr>
<tr class="separator:affc77be35235acbc1b67e60e7670194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1b10a5a2f14a9bec516ff47bcba96761"><td class="memTemplParams" colspan="2">template&lt;typename TImageType &gt; </td></tr>
<tr class="memitem:a1b10a5a2f14a9bec516ff47bcba96761"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1b10a5a2f14a9bec516ff47bcba96761">Image</a> (<a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>&lt; TImageType &gt; image)</td></tr>
<tr class="memdesc:a1b10a5a2f14a9bec516ff47bcba96761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image.  <a href="classitk_1_1simple_1_1Image.html#a1b10a5a2f14a9bec516ff47bcba96761">More...</a><br /></td></tr>
<tr class="separator:a1b10a5a2f14a9bec516ff47bcba96761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135e55d13e3baf01d3cd906d40558605"><td class="memTemplParams" colspan="2">template&lt;typename TImageType &gt; </td></tr>
<tr class="memitem:a135e55d13e3baf01d3cd906d40558605"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a135e55d13e3baf01d3cd906d40558605">Image</a> (TImageType *image)</td></tr>
<tr class="memdesc:a135e55d13e3baf01d3cd906d40558605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image.  <a href="classitk_1_1simple_1_1Image.html#a135e55d13e3baf01d3cd906d40558605">More...</a><br /></td></tr>
<tr class="separator:a135e55d13e3baf01d3cd906d40558605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a600c5cd0fe2345b2d0a2e09997dfa1d6"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a600c5cd0fe2345b2d0a2e09997dfa1d6">GetITKBase</a> ()</td></tr>
<tr class="separator:a600c5cd0fe2345b2d0a2e09997dfa1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590b6dd151816ef8a4b549e95ed1bf57"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a590b6dd151816ef8a4b549e95ed1bf57">GetITKBase</a> () const</td></tr>
<tr class="separator:a590b6dd151816ef8a4b549e95ed1bf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a622920d3325ee831eba2ddad89d7eb3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a622920d3325ee831eba2ddad89d7eb3d">GetOrigin</a> () const</td></tr>
<tr class="separator:a622920d3325ee831eba2ddad89d7eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9648b61b714ddd980d3b7b78bf5562ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a9648b61b714ddd980d3b7b78bf5562ed">SetOrigin</a> (const std::vector&lt; double &gt; &amp;origin)</td></tr>
<tr class="separator:a9648b61b714ddd980d3b7b78bf5562ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a669907e56274c6ca2838be3bf4a5ac9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a669907e56274c6ca2838be3bf4a5ac9f">GetSpacing</a> () const</td></tr>
<tr class="separator:a669907e56274c6ca2838be3bf4a5ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b285752e1a79e123c055dc6fa95a50a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1b285752e1a79e123c055dc6fa95a50a">SetSpacing</a> (const std::vector&lt; double &gt; &amp;spacing)</td></tr>
<tr class="separator:a1b285752e1a79e123c055dc6fa95a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7bd35f108a2df5c966285405af409548"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a7bd35f108a2df5c966285405af409548">GetDirection</a> () const</td></tr>
<tr class="memdesc:a7bd35f108a2df5c966285405af409548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the Direction.  <a href="classitk_1_1simple_1_1Image.html#a7bd35f108a2df5c966285405af409548">More...</a><br /></td></tr>
<tr class="separator:a7bd35f108a2df5c966285405af409548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d6c8b3777b454b6da1ee1d3e7ed56f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a04d6c8b3777b454b6da1ee1d3e7ed56f">SetDirection</a> (const std::vector&lt; double &gt; &amp;direction)</td></tr>
<tr class="memdesc:a04d6c8b3777b454b6da1ee1d3e7ed56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the Direction.  <a href="classitk_1_1simple_1_1Image.html#a04d6c8b3777b454b6da1ee1d3e7ed56f">More...</a><br /></td></tr>
<tr class="separator:a04d6c8b3777b454b6da1ee1d3e7ed56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0c57fd2e652cef42678df6721ee91ef"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ad0c57fd2e652cef42678df6721ee91ef">GetPixelAsInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ad0c57fd2e652cef42678df6721ee91ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#ad0c57fd2e652cef42678df6721ee91ef">More...</a><br /></td></tr>
<tr class="separator:ad0c57fd2e652cef42678df6721ee91ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1e93337f99f36e695921bb1e699126"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a9c1e93337f99f36e695921bb1e699126">GetPixelAsUInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a9c1e93337f99f36e695921bb1e699126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a9c1e93337f99f36e695921bb1e699126">More...</a><br /></td></tr>
<tr class="separator:a9c1e93337f99f36e695921bb1e699126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36e43923c39880321b04eda1436c4e2"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ab36e43923c39880321b04eda1436c4e2">GetPixelAsInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ab36e43923c39880321b04eda1436c4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#ab36e43923c39880321b04eda1436c4e2">More...</a><br /></td></tr>
<tr class="separator:ab36e43923c39880321b04eda1436c4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda2c933c0fc074041619f292d53b3f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a7bda2c933c0fc074041619f292d53b3f">GetPixelAsUInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a7bda2c933c0fc074041619f292d53b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a7bda2c933c0fc074041619f292d53b3f">More...</a><br /></td></tr>
<tr class="separator:a7bda2c933c0fc074041619f292d53b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd014ee850c3b779b242577c795d568d"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#abd014ee850c3b779b242577c795d568d">GetPixelAsInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:abd014ee850c3b779b242577c795d568d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#abd014ee850c3b779b242577c795d568d">More...</a><br /></td></tr>
<tr class="separator:abd014ee850c3b779b242577c795d568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e68cff0ddbee6c0516d2f5436df4d3"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a54e68cff0ddbee6c0516d2f5436df4d3">GetPixelAsUInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a54e68cff0ddbee6c0516d2f5436df4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a54e68cff0ddbee6c0516d2f5436df4d3">More...</a><br /></td></tr>
<tr class="separator:a54e68cff0ddbee6c0516d2f5436df4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1955c632dd4c04be1573d4dbadfcdec"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ae1955c632dd4c04be1573d4dbadfcdec">GetPixelAsInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ae1955c632dd4c04be1573d4dbadfcdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#ae1955c632dd4c04be1573d4dbadfcdec">More...</a><br /></td></tr>
<tr class="separator:ae1955c632dd4c04be1573d4dbadfcdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef2dd54b1b62e61e92026b92a8e8dfa"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aeef2dd54b1b62e61e92026b92a8e8dfa">GetPixelAsUInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:aeef2dd54b1b62e61e92026b92a8e8dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#aeef2dd54b1b62e61e92026b92a8e8dfa">More...</a><br /></td></tr>
<tr class="separator:aeef2dd54b1b62e61e92026b92a8e8dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e04ac6dc1e3a789f6b5f3fde6a704ad"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a6e04ac6dc1e3a789f6b5f3fde6a704ad">GetPixelAsFloat</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a6e04ac6dc1e3a789f6b5f3fde6a704ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a6e04ac6dc1e3a789f6b5f3fde6a704ad">More...</a><br /></td></tr>
<tr class="separator:a6e04ac6dc1e3a789f6b5f3fde6a704ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958fc359792de9213e87dc20f8fa400d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a958fc359792de9213e87dc20f8fa400d">GetPixelAsDouble</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a958fc359792de9213e87dc20f8fa400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a958fc359792de9213e87dc20f8fa400d">More...</a><br /></td></tr>
<tr class="separator:a958fc359792de9213e87dc20f8fa400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da3f19798a0c30488ab412e3d707505"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a8da3f19798a0c30488ab412e3d707505">GetPixelAsVectorInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a8da3f19798a0c30488ab412e3d707505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a8da3f19798a0c30488ab412e3d707505">More...</a><br /></td></tr>
<tr class="separator:a8da3f19798a0c30488ab412e3d707505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd696c8b0f218ea75c97c86db5983d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#acdd696c8b0f218ea75c97c86db5983d2">GetPixelAsVectorUInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:acdd696c8b0f218ea75c97c86db5983d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#acdd696c8b0f218ea75c97c86db5983d2">More...</a><br /></td></tr>
<tr class="separator:acdd696c8b0f218ea75c97c86db5983d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115dd3ac39fe400bc5015a6f04231061"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a115dd3ac39fe400bc5015a6f04231061">GetPixelAsVectorInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a115dd3ac39fe400bc5015a6f04231061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a115dd3ac39fe400bc5015a6f04231061">More...</a><br /></td></tr>
<tr class="separator:a115dd3ac39fe400bc5015a6f04231061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae280918c7fa7fa0f517442d82a1ca631"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ae280918c7fa7fa0f517442d82a1ca631">GetPixelAsVectorUInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ae280918c7fa7fa0f517442d82a1ca631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#ae280918c7fa7fa0f517442d82a1ca631">More...</a><br /></td></tr>
<tr class="separator:ae280918c7fa7fa0f517442d82a1ca631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaf8347c90dcd454e2f2d87c3b9078c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a6eaf8347c90dcd454e2f2d87c3b9078c">GetPixelAsVectorInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a6eaf8347c90dcd454e2f2d87c3b9078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a6eaf8347c90dcd454e2f2d87c3b9078c">More...</a><br /></td></tr>
<tr class="separator:a6eaf8347c90dcd454e2f2d87c3b9078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc761996e1b65903d7f003824da793f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aacc761996e1b65903d7f003824da793f">GetPixelAsVectorUInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:aacc761996e1b65903d7f003824da793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#aacc761996e1b65903d7f003824da793f">More...</a><br /></td></tr>
<tr class="separator:aacc761996e1b65903d7f003824da793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd82663427b6ee5736ebc1dfedf51b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a0ecd82663427b6ee5736ebc1dfedf51b">GetPixelAsVectorInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a0ecd82663427b6ee5736ebc1dfedf51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a0ecd82663427b6ee5736ebc1dfedf51b">More...</a><br /></td></tr>
<tr class="separator:a0ecd82663427b6ee5736ebc1dfedf51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa93e9578bcf1f93e6e4d0c9b85949e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#affa93e9578bcf1f93e6e4d0c9b85949e">GetPixelAsVectorUInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:affa93e9578bcf1f93e6e4d0c9b85949e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#affa93e9578bcf1f93e6e4d0c9b85949e">More...</a><br /></td></tr>
<tr class="separator:affa93e9578bcf1f93e6e4d0c9b85949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26348f6e3a42a837a455d611de8485e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a26348f6e3a42a837a455d611de8485e1">GetPixelAsVectorFloat32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a26348f6e3a42a837a455d611de8485e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a26348f6e3a42a837a455d611de8485e1">More...</a><br /></td></tr>
<tr class="separator:a26348f6e3a42a837a455d611de8485e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c9ed9277ffd2690aecc000e974c07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aab7c9ed9277ffd2690aecc000e974c07">GetPixelAsVectorFloat64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:aab7c9ed9277ffd2690aecc000e974c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#aab7c9ed9277ffd2690aecc000e974c07">More...</a><br /></td></tr>
<tr class="separator:aab7c9ed9277ffd2690aecc000e974c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb89bcefd90119d4b55407be5b30cc25"><td class="memItemLeft" align="right" valign="top">std::complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#adb89bcefd90119d4b55407be5b30cc25">GetPixelAsComplexFloat32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:adb89bcefd90119d4b55407be5b30cc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#adb89bcefd90119d4b55407be5b30cc25">More...</a><br /></td></tr>
<tr class="separator:adb89bcefd90119d4b55407be5b30cc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1889da3071e6aa7daaa673db7be89266"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1889da3071e6aa7daaa673db7be89266">GetPixelAsComplexFloat64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a1889da3071e6aa7daaa673db7be89266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a1889da3071e6aa7daaa673db7be89266">More...</a><br /></td></tr>
<tr class="separator:a1889da3071e6aa7daaa673db7be89266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c01f6319e38f168010c6c597465a146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a8c01f6319e38f168010c6c597465a146">SetPixelAsInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> v)</td></tr>
<tr class="memdesc:a8c01f6319e38f168010c6c597465a146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a8c01f6319e38f168010c6c597465a146">More...</a><br /></td></tr>
<tr class="separator:a8c01f6319e38f168010c6c597465a146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe256cff6ccbcb37f89a61a83fda0763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#abe256cff6ccbcb37f89a61a83fda0763">SetPixelAsUInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> v)</td></tr>
<tr class="memdesc:abe256cff6ccbcb37f89a61a83fda0763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#abe256cff6ccbcb37f89a61a83fda0763">More...</a><br /></td></tr>
<tr class="separator:abe256cff6ccbcb37f89a61a83fda0763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75442c64fc1933c088c02ef11be5373a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a75442c64fc1933c088c02ef11be5373a">SetPixelAsInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> v)</td></tr>
<tr class="memdesc:a75442c64fc1933c088c02ef11be5373a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a75442c64fc1933c088c02ef11be5373a">More...</a><br /></td></tr>
<tr class="separator:a75442c64fc1933c088c02ef11be5373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50743b5a080be742524c461a4f1aa320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a50743b5a080be742524c461a4f1aa320">SetPixelAsUInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> v)</td></tr>
<tr class="memdesc:a50743b5a080be742524c461a4f1aa320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a50743b5a080be742524c461a4f1aa320">More...</a><br /></td></tr>
<tr class="separator:a50743b5a080be742524c461a4f1aa320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9214c2b5437c831eff5a5ca220439c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a5b9214c2b5437c831eff5a5ca220439c">SetPixelAsInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> v)</td></tr>
<tr class="memdesc:a5b9214c2b5437c831eff5a5ca220439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a5b9214c2b5437c831eff5a5ca220439c">More...</a><br /></td></tr>
<tr class="separator:a5b9214c2b5437c831eff5a5ca220439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586633efa5fd70f1769a5e2255459264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a586633efa5fd70f1769a5e2255459264">SetPixelAsUInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> v)</td></tr>
<tr class="memdesc:a586633efa5fd70f1769a5e2255459264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a586633efa5fd70f1769a5e2255459264">More...</a><br /></td></tr>
<tr class="separator:a586633efa5fd70f1769a5e2255459264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2c9ff8b97b2ffd9c8a7b106377a0f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a3f2c9ff8b97b2ffd9c8a7b106377a0f8">SetPixelAsInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> v)</td></tr>
<tr class="memdesc:a3f2c9ff8b97b2ffd9c8a7b106377a0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a3f2c9ff8b97b2ffd9c8a7b106377a0f8">More...</a><br /></td></tr>
<tr class="separator:a3f2c9ff8b97b2ffd9c8a7b106377a0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6088cb5d92145f9aec2f82b4b273dee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a6088cb5d92145f9aec2f82b4b273dee5">SetPixelAsUInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> v)</td></tr>
<tr class="memdesc:a6088cb5d92145f9aec2f82b4b273dee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a6088cb5d92145f9aec2f82b4b273dee5">More...</a><br /></td></tr>
<tr class="separator:a6088cb5d92145f9aec2f82b4b273dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae243d0aa8d3a1f0b5c8a5335d21ae2e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ae243d0aa8d3a1f0b5c8a5335d21ae2e5">SetPixelAsFloat</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, float v)</td></tr>
<tr class="memdesc:ae243d0aa8d3a1f0b5c8a5335d21ae2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#ae243d0aa8d3a1f0b5c8a5335d21ae2e5">More...</a><br /></td></tr>
<tr class="separator:ae243d0aa8d3a1f0b5c8a5335d21ae2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba546cc106fc7af755421fa6fe72871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1ba546cc106fc7af755421fa6fe72871">SetPixelAsDouble</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, double v)</td></tr>
<tr class="memdesc:a1ba546cc106fc7af755421fa6fe72871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a1ba546cc106fc7af755421fa6fe72871">More...</a><br /></td></tr>
<tr class="separator:a1ba546cc106fc7af755421fa6fe72871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e10b7b03904ff90b38e9cc92ccf1ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a88e10b7b03904ff90b38e9cc92ccf1ef">SetPixelAsVectorInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a88e10b7b03904ff90b38e9cc92ccf1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a88e10b7b03904ff90b38e9cc92ccf1ef">More...</a><br /></td></tr>
<tr class="separator:a88e10b7b03904ff90b38e9cc92ccf1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e53202d40fd48f6d4b9fb55f2ed9c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1e53202d40fd48f6d4b9fb55f2ed9c6d">SetPixelAsVectorUInt8</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a1e53202d40fd48f6d4b9fb55f2ed9c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a1e53202d40fd48f6d4b9fb55f2ed9c6d">More...</a><br /></td></tr>
<tr class="separator:a1e53202d40fd48f6d4b9fb55f2ed9c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235e853836366fac8ee98de3d80fb866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a235e853836366fac8ee98de3d80fb866">SetPixelAsVectorInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a235e853836366fac8ee98de3d80fb866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a235e853836366fac8ee98de3d80fb866">More...</a><br /></td></tr>
<tr class="separator:a235e853836366fac8ee98de3d80fb866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3627592f3f167e398a3b4b43ab1d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a7d3627592f3f167e398a3b4b43ab1d91">SetPixelAsVectorUInt16</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a7d3627592f3f167e398a3b4b43ab1d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a7d3627592f3f167e398a3b4b43ab1d91">More...</a><br /></td></tr>
<tr class="separator:a7d3627592f3f167e398a3b4b43ab1d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8b8d47857d714e5c1cc06f0dc78b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a8c8b8d47857d714e5c1cc06f0dc78b43">SetPixelAsVectorInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a8c8b8d47857d714e5c1cc06f0dc78b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a8c8b8d47857d714e5c1cc06f0dc78b43">More...</a><br /></td></tr>
<tr class="separator:a8c8b8d47857d714e5c1cc06f0dc78b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6ae62b2ba271d90764e03ba3155f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aeb6ae62b2ba271d90764e03ba3155f3f">SetPixelAsVectorUInt32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:aeb6ae62b2ba271d90764e03ba3155f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#aeb6ae62b2ba271d90764e03ba3155f3f">More...</a><br /></td></tr>
<tr class="separator:aeb6ae62b2ba271d90764e03ba3155f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab595292b40ced613b36411608f1408a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ab595292b40ced613b36411608f1408a9">SetPixelAsVectorInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ab595292b40ced613b36411608f1408a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#ab595292b40ced613b36411608f1408a9">More...</a><br /></td></tr>
<tr class="separator:ab595292b40ced613b36411608f1408a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc04519f671706868e9c642cf1e4dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aecc04519f671706868e9c642cf1e4dad">SetPixelAsVectorUInt64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:aecc04519f671706868e9c642cf1e4dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#aecc04519f671706868e9c642cf1e4dad">More...</a><br /></td></tr>
<tr class="separator:aecc04519f671706868e9c642cf1e4dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862c2f02ce7abc80943e1cbbb75f8954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a862c2f02ce7abc80943e1cbbb75f8954">SetPixelAsVectorFloat32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; float &gt; &amp;v)</td></tr>
<tr class="memdesc:a862c2f02ce7abc80943e1cbbb75f8954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#a862c2f02ce7abc80943e1cbbb75f8954">More...</a><br /></td></tr>
<tr class="separator:a862c2f02ce7abc80943e1cbbb75f8954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0326247d1ca5051fba7d1c07b676099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ae0326247d1ca5051fba7d1c07b676099">SetPixelAsVectorFloat64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="memdesc:ae0326247d1ca5051fba7d1c07b676099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#ae0326247d1ca5051fba7d1c07b676099">More...</a><br /></td></tr>
<tr class="separator:ae0326247d1ca5051fba7d1c07b676099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff869ab52a6b49bfbb4caa4a8ade6209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aff869ab52a6b49bfbb4caa4a8ade6209">SetPixelAsComplexFloat32</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::complex&lt; float &gt; v)</td></tr>
<tr class="memdesc:aff869ab52a6b49bfbb4caa4a8ade6209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#aff869ab52a6b49bfbb4caa4a8ade6209">More...</a><br /></td></tr>
<tr class="separator:aff869ab52a6b49bfbb4caa4a8ade6209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb107c591ef00628fe9b3d3ff8b369ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#adb107c591ef00628fe9b3d3ff8b369ac">SetPixelAsComplexFloat64</a> (const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;idx, const std::complex&lt; double &gt; v)</td></tr>
<tr class="memdesc:adb107c591ef00628fe9b3d3ff8b369ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <a href="classitk_1_1simple_1_1Image.html#adb107c591ef00628fe9b3d3ff8b369ac">More...</a><br /></td></tr>
<tr class="separator:adb107c591ef00628fe9b3d3ff8b369ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa638d156039b08584904cda2e20157c1"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aa638d156039b08584904cda2e20157c1">GetBufferAsInt8</a> ()</td></tr>
<tr class="memdesc:aa638d156039b08584904cda2e20157c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#aa638d156039b08584904cda2e20157c1">More...</a><br /></td></tr>
<tr class="separator:aa638d156039b08584904cda2e20157c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b011a5e138e90d1375955ba271533a8"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a9b011a5e138e90d1375955ba271533a8">GetBufferAsUInt8</a> ()</td></tr>
<tr class="memdesc:a9b011a5e138e90d1375955ba271533a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a9b011a5e138e90d1375955ba271533a8">More...</a><br /></td></tr>
<tr class="separator:a9b011a5e138e90d1375955ba271533a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f6a12886842f236958f8b3e89833c7"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a69f6a12886842f236958f8b3e89833c7">GetBufferAsInt16</a> ()</td></tr>
<tr class="memdesc:a69f6a12886842f236958f8b3e89833c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a69f6a12886842f236958f8b3e89833c7">More...</a><br /></td></tr>
<tr class="separator:a69f6a12886842f236958f8b3e89833c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfa9b811d8cd281dae9e207dbf4c192"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a8bfa9b811d8cd281dae9e207dbf4c192">GetBufferAsUInt16</a> ()</td></tr>
<tr class="memdesc:a8bfa9b811d8cd281dae9e207dbf4c192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a8bfa9b811d8cd281dae9e207dbf4c192">More...</a><br /></td></tr>
<tr class="separator:a8bfa9b811d8cd281dae9e207dbf4c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce813ee554356d8153701bebca63981"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a7ce813ee554356d8153701bebca63981">GetBufferAsInt32</a> ()</td></tr>
<tr class="memdesc:a7ce813ee554356d8153701bebca63981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a7ce813ee554356d8153701bebca63981">More...</a><br /></td></tr>
<tr class="separator:a7ce813ee554356d8153701bebca63981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c7fff9e735d24c0a4dbe244ee92f6"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1b7c7fff9e735d24c0a4dbe244ee92f6">GetBufferAsUInt32</a> ()</td></tr>
<tr class="memdesc:a1b7c7fff9e735d24c0a4dbe244ee92f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a1b7c7fff9e735d24c0a4dbe244ee92f6">More...</a><br /></td></tr>
<tr class="separator:a1b7c7fff9e735d24c0a4dbe244ee92f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d1ac71dc6d45175ce08c3ae2b12539"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a14d1ac71dc6d45175ce08c3ae2b12539">GetBufferAsInt64</a> ()</td></tr>
<tr class="memdesc:a14d1ac71dc6d45175ce08c3ae2b12539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a14d1ac71dc6d45175ce08c3ae2b12539">More...</a><br /></td></tr>
<tr class="separator:a14d1ac71dc6d45175ce08c3ae2b12539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6049da4ed7956e16faf093ec63778389"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a6049da4ed7956e16faf093ec63778389">GetBufferAsUInt64</a> ()</td></tr>
<tr class="memdesc:a6049da4ed7956e16faf093ec63778389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a6049da4ed7956e16faf093ec63778389">More...</a><br /></td></tr>
<tr class="separator:a6049da4ed7956e16faf093ec63778389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad896f3be099548ad24a160aa1a4ed357"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ad896f3be099548ad24a160aa1a4ed357">GetBufferAsFloat</a> ()</td></tr>
<tr class="memdesc:ad896f3be099548ad24a160aa1a4ed357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#ad896f3be099548ad24a160aa1a4ed357">More...</a><br /></td></tr>
<tr class="separator:ad896f3be099548ad24a160aa1a4ed357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f6ed5fff8ee5d371e6a3671d0cae6a"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ab7f6ed5fff8ee5d371e6a3671d0cae6a">GetBufferAsDouble</a> ()</td></tr>
<tr class="memdesc:ab7f6ed5fff8ee5d371e6a3671d0cae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#ab7f6ed5fff8ee5d371e6a3671d0cae6a">More...</a><br /></td></tr>
<tr class="separator:ab7f6ed5fff8ee5d371e6a3671d0cae6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ddb6ba0b3e4e351802ce3e65c23e1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a827ddb6ba0b3e4e351802ce3e65c23e1">GetBufferAsVoid</a> ()</td></tr>
<tr class="memdesc:a827ddb6ba0b3e4e351802ce3e65c23e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a827ddb6ba0b3e4e351802ce3e65c23e1">More...</a><br /></td></tr>
<tr class="separator:a827ddb6ba0b3e4e351802ce3e65c23e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69898006932ab663c6d1ce6775367821"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a69898006932ab663c6d1ce6775367821">GetBufferAsInt8</a> () const</td></tr>
<tr class="memdesc:a69898006932ab663c6d1ce6775367821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a69898006932ab663c6d1ce6775367821">More...</a><br /></td></tr>
<tr class="separator:a69898006932ab663c6d1ce6775367821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f0a6dc3bfd68cc3c6c400d23ef23c"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a2b1f0a6dc3bfd68cc3c6c400d23ef23c">GetBufferAsUInt8</a> () const</td></tr>
<tr class="memdesc:a2b1f0a6dc3bfd68cc3c6c400d23ef23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a2b1f0a6dc3bfd68cc3c6c400d23ef23c">More...</a><br /></td></tr>
<tr class="separator:a2b1f0a6dc3bfd68cc3c6c400d23ef23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa805efe6118819d5d2e41fdd2dd5f57d"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aa805efe6118819d5d2e41fdd2dd5f57d">GetBufferAsInt16</a> () const</td></tr>
<tr class="memdesc:aa805efe6118819d5d2e41fdd2dd5f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#aa805efe6118819d5d2e41fdd2dd5f57d">More...</a><br /></td></tr>
<tr class="separator:aa805efe6118819d5d2e41fdd2dd5f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3de1a5a1ec46d65f23f985abf37b938"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ad3de1a5a1ec46d65f23f985abf37b938">GetBufferAsUInt16</a> () const</td></tr>
<tr class="memdesc:ad3de1a5a1ec46d65f23f985abf37b938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#ad3de1a5a1ec46d65f23f985abf37b938">More...</a><br /></td></tr>
<tr class="separator:ad3de1a5a1ec46d65f23f985abf37b938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7d8fe774ea0535c2dbe6001a129e40"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aae7d8fe774ea0535c2dbe6001a129e40">GetBufferAsInt32</a> () const</td></tr>
<tr class="memdesc:aae7d8fe774ea0535c2dbe6001a129e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#aae7d8fe774ea0535c2dbe6001a129e40">More...</a><br /></td></tr>
<tr class="separator:aae7d8fe774ea0535c2dbe6001a129e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe46fa62d720c617997736d91ca96ca"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aebe46fa62d720c617997736d91ca96ca">GetBufferAsUInt32</a> () const</td></tr>
<tr class="memdesc:aebe46fa62d720c617997736d91ca96ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#aebe46fa62d720c617997736d91ca96ca">More...</a><br /></td></tr>
<tr class="separator:aebe46fa62d720c617997736d91ca96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e6c1b579b0dd626a75c2d87086b06"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a577e6c1b579b0dd626a75c2d87086b06">GetBufferAsInt64</a> () const</td></tr>
<tr class="memdesc:a577e6c1b579b0dd626a75c2d87086b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a577e6c1b579b0dd626a75c2d87086b06">More...</a><br /></td></tr>
<tr class="separator:a577e6c1b579b0dd626a75c2d87086b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a79f8ee1d6d1c118baeab9708f80e1"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ac2a79f8ee1d6d1c118baeab9708f80e1">GetBufferAsUInt64</a> () const</td></tr>
<tr class="memdesc:ac2a79f8ee1d6d1c118baeab9708f80e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#ac2a79f8ee1d6d1c118baeab9708f80e1">More...</a><br /></td></tr>
<tr class="separator:ac2a79f8ee1d6d1c118baeab9708f80e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab903a0f7917525347ed46d3d658e057d"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#ab903a0f7917525347ed46d3d658e057d">GetBufferAsFloat</a> () const</td></tr>
<tr class="memdesc:ab903a0f7917525347ed46d3d658e057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#ab903a0f7917525347ed46d3d658e057d">More...</a><br /></td></tr>
<tr class="separator:ab903a0f7917525347ed46d3d658e057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ad1cd0da557e6bdadacd027d5e95c5"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a12ad1cd0da557e6bdadacd027d5e95c5">GetBufferAsDouble</a> () const</td></tr>
<tr class="memdesc:a12ad1cd0da557e6bdadacd027d5e95c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#a12ad1cd0da557e6bdadacd027d5e95c5">More...</a><br /></td></tr>
<tr class="separator:a12ad1cd0da557e6bdadacd027d5e95c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd4b5ac2632c7dcc33b971229a51be6"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aabd4b5ac2632c7dcc33b971229a51be6">GetBufferAsVoid</a> () const</td></tr>
<tr class="memdesc:aabd4b5ac2632c7dcc33b971229a51be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <a href="classitk_1_1simple_1_1Image.html#aabd4b5ac2632c7dcc33b971229a51be6">More...</a><br /></td></tr>
<tr class="separator:aabd4b5ac2632c7dcc33b971229a51be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1cd9b3cdfa9e9159f48cf84ef4461d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a1cd9b3cdfa9e9159f48cf84ef4461d55">Allocate</a> (const std::vector&lt; unsigned int &gt; &amp;size, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum, unsigned int numberOfComponents)</td></tr>
<tr class="memdesc:a1cd9b3cdfa9e9159f48cf84ef4461d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods called by the constructor to allocate and initialize an image.  <a href="classitk_1_1simple_1_1Image.html#a1cd9b3cdfa9e9159f48cf84ef4461d55">More...</a><br /></td></tr>
<tr class="separator:a1cd9b3cdfa9e9159f48cf84ef4461d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2a4a368b62eaf8d8e86bc351e7e25c1e"><td class="memTemplParams" colspan="2">template&lt;class TImageType &gt; </td></tr>
<tr class="memitem:a2a4a368b62eaf8d8e86bc351e7e25c1e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structitk_1_1simple_1_1IsBasic.html">IsBasic</a>&lt; TImageType &gt;::Value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a2a4a368b62eaf8d8e86bc351e7e25c1e">AllocateInternal</a> (const std::vector&lt; unsigned int &gt; &amp;size, unsigned int numberOfComponents)</td></tr>
<tr class="memdesc:a2a4a368b62eaf8d8e86bc351e7e25c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatched methods for allocating images.  <a href="classitk_1_1simple_1_1Image.html#a2a4a368b62eaf8d8e86bc351e7e25c1e">More...</a><br /></td></tr>
<tr class="separator:a2a4a368b62eaf8d8e86bc351e7e25c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc385a1c1ce92435adf1e7400d69f227"><td class="memTemplParams" colspan="2">template&lt;class TImageType &gt; </td></tr>
<tr class="memitem:acc385a1c1ce92435adf1e7400d69f227"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structitk_1_1simple_1_1IsVector.html">IsVector</a>&lt; TImageType &gt;::Value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#acc385a1c1ce92435adf1e7400d69f227">AllocateInternal</a> (const std::vector&lt; unsigned int &gt; &amp;size, unsigned int numberOfComponents)</td></tr>
<tr class="memdesc:acc385a1c1ce92435adf1e7400d69f227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatched methods for allocating images.  <a href="classitk_1_1simple_1_1Image.html#acc385a1c1ce92435adf1e7400d69f227">More...</a><br /></td></tr>
<tr class="separator:acc385a1c1ce92435adf1e7400d69f227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf9d4ad3e18aeff822af3589005b3de"><td class="memTemplParams" colspan="2">template&lt;class TImageType &gt; </td></tr>
<tr class="memitem:aebf9d4ad3e18aeff822af3589005b3de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structitk_1_1simple_1_1IsLabel.html">IsLabel</a>&lt; TImageType &gt;::Value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aebf9d4ad3e18aeff822af3589005b3de">AllocateInternal</a> (const std::vector&lt; unsigned int &gt; &amp;size, unsigned int numberOfComponents)</td></tr>
<tr class="memdesc:aebf9d4ad3e18aeff822af3589005b3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatched methods for allocating images.  <a href="classitk_1_1simple_1_1Image.html#aebf9d4ad3e18aeff822af3589005b3de">More...</a><br /></td></tr>
<tr class="separator:aebf9d4ad3e18aeff822af3589005b3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6ad2b5c0e5f9d94d953e8e4469bbfa1e"><td class="memTemplParams" colspan="2">template&lt;int VPixelIDValue, unsigned int VImageDimension&gt; </td></tr>
<tr class="memitem:a6ad2b5c0e5f9d94d953e8e4469bbfa1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a6ad2b5c0e5f9d94d953e8e4469bbfa1e">InternalInitialization</a> (typename <a class="el" href="structitk_1_1simple_1_1PixelIDToImageType.html">PixelIDToImageType</a>&lt; typename typelist::TypeAt&lt; <a class="el" href="namespaceitk_1_1simple.html#aca9bcea069d3753ee0303e2d0b9270af">InstantiatedPixelIDTypeList</a>, VPixelIDValue &gt;::Result, VImageDimension &gt;::ImageType *i)</td></tr>
<tr class="separator:a6ad2b5c0e5f9d94d953e8e4469bbfa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aee7565c1e6714813f611d0bc8cdca97b"><td class="memTemplParams" colspan="2">template&lt;int VPixelIDValue, typename TImageType &gt; </td></tr>
<tr class="memitem:aee7565c1e6714813f611d0bc8cdca97b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; TImageType, void &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#aee7565c1e6714813f611d0bc8cdca97b">ConditionalInternalInitialization</a> (TImageType *i)</td></tr>
<tr class="separator:aee7565c1e6714813f611d0bc8cdca97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21171308dcd275a9c80891dac6ca1cc7"><td class="memTemplParams" colspan="2">template&lt;int VPixelIDValue, typename TImageType &gt; </td></tr>
<tr class="memitem:a21171308dcd275a9c80891dac6ca1cc7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; TImageType, void &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a21171308dcd275a9c80891dac6ca1cc7">ConditionalInternalInitialization</a> (TImageType *)</td></tr>
<tr class="separator:a21171308dcd275a9c80891dac6ca1cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a76b5c98046d927e528a449442420a448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1simple_1_1Image.html#a76b5c98046d927e528a449442420a448">m_PimpleImage</a></td></tr>
<tr class="separator:a76b5c98046d927e528a449442420a448"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class for SimpleITK. </p>
<p >This <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class can represent 2D, 3D, and 4D images. The pixel types may be a scalar, a multi-component vector or a run-length-encoded (RLE) "label". The dimension, pixel type and size is specified at construction.</p>
<p >A fundamental concept of ITK images is that they occupy physical space where the image is defined by an origin, spacing, and direction cosine matrix. The attributes are taken into consideration when doing most operations on an image. A meta-data dictionary is also associated with the image, which may contain additional fields from reading but these attributes are not propagated by image filters.</p>
<p >The SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> provides a single facade interface to several ITK image types. Internally, the SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> maintains a pointer to the ITK image class, and performs reference counting and lazy copying. This means that deep copying of an image including it's buffer is delayed until the image is modified. This removes the need to use pointers to SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class, as copying and returning by value do not unnecessarily duplicate the data.</p>
<p >/sa <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Image.html">itk::Image</a> <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1VectorImage.html">itk::VectorImage</a> <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1LabelMap.html">itk::LabelMap</a> <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1ImageBase.html">itk::ImageBase</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="BufferImportExport_8cxx-example.html#_a5">BufferImportExport.cxx</a>, <a class="el" href="CppCMake_2Source_2sitk_example_8cxx-example.html#_a1">CppCMake/Source/sitk_example.cxx</a>, <a class="el" href="CppInPlace_2CppInPlace_8cxx-example.html#_a0">CppInPlace/CppInPlace.cxx</a>, <a class="el" href="DemonsRegistration1_2DemonsRegistration1_8cxx-example.html#_a3">DemonsRegistration1/DemonsRegistration1.cxx</a>, <a class="el" href="DemonsRegistration2_2DemonsRegistration2_8cxx-example.html#_a3">DemonsRegistration2/DemonsRegistration2.cxx</a>, <a class="el" href="DicomSeriesReader_2DicomSeriesReader_8cxx-example.html#_a3">DicomSeriesReader/DicomSeriesReader.cxx</a>, <a class="el" href="FastMarchingSegmentation_2FastMarchingSegmentation_8cxx-example.html#_a0">FastMarchingSegmentation/FastMarchingSegmentation.cxx</a>, <a class="el" href="FilterProgressReporting_2FilterProgressReporting_8cxx-example.html#_a5">FilterProgressReporting/FilterProgressReporting.cxx</a>, <a class="el" href="HelloWorld_2HelloWorld_8cxx-example.html#_a1">HelloWorld/HelloWorld.cxx</a>, <a class="el" href="ITKIntegration_2ITKIntegration_8cxx-example.html#_a2">ITKIntegration/ITKIntegration.cxx</a>, <a class="el" href="ImageIOSelection_2ImageIOSelection_8cxx-example.html#_a5">ImageIOSelection/ImageIOSelection.cxx</a>, <a class="el" href="ImageRegistrationMethod1_2ImageRegistrationMethod1_8cxx-example.html#_a3">ImageRegistrationMethod1/ImageRegistrationMethod1.cxx</a>, <a class="el" href="ImageRegistrationMethod2_2ImageRegistrationMethod2_8cxx-example.html#_a3">ImageRegistrationMethod2/ImageRegistrationMethod2.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline1_2ImageRegistrationMethodBSpline1_8cxx-example.html#_a3">ImageRegistrationMethodBSpline1/ImageRegistrationMethodBSpline1.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline3_2ImageRegistrationMethodBSpline3_8cxx-example.html#_a4">ImageRegistrationMethodBSpline3/ImageRegistrationMethodBSpline3.cxx</a>, <a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#_a3">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>, <a class="el" href="N4BiasFieldCorrection_2N4BiasFieldCorrection_8cxx-example.html#_a0">N4BiasFieldCorrection/N4BiasFieldCorrection.cxx</a>, <a class="el" href="Segmentation_2ConnectedThresholdImageFilter_8cxx-example.html#_a2">Segmentation/ConnectedThresholdImageFilter.cxx</a>, <a class="el" href="Segmentation_2NeighborhoodConnectedImageFilter_8cxx-example.html#_a2">Segmentation/NeighborhoodConnectedImageFilter.cxx</a>, <a class="el" href="SimpleGaussian_2SimpleGaussian_8cxx-example.html#_a2">SimpleGaussian/SimpleGaussian.cxx</a>, <a class="el" href="SimpleGaussianFunctional_8cxx-example.html#_a0">SimpleGaussianFunctional.cxx</a>, <a class="el" href="SimpleIO_2SimpleIO_8cxx-example.html#_a3">SimpleIO/SimpleIO.cxx</a>, and <a class="el" href="SliceBySliceDecorator_2SliceBySliceDecorator_8cxx-example.html#_a0">SliceBySliceDecorator/SliceBySliceDecorator.cxx</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00076">76</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5f3a8beb0170782f77853b044ddd02a4" name="a5f3a8beb0170782f77853b044ddd02a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3a8beb0170782f77853b044ddd02a4">&#9670;&nbsp;</a></span>Self</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1simple_1_1Image.html#a5f3a8beb0170782f77853b044ddd02a4">itk::simple::Image::Self</a> =  <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00079">79</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adef33af720d7ce65533fbb10b2b53f51" name="adef33af720d7ce65533fbb10b2b53f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef33af720d7ce65533fbb10b2b53f51">&#9670;&nbsp;</a></span>~Image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual itk::simple::Image::~Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42a8055958ef17e5fd3602e68e28fcc7" name="a42a8055958ef17e5fd3602e68e28fcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a8055958ef17e5fd3602e68e28fcc7">&#9670;&nbsp;</a></span>Image() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor, creates an image of size 0. </p>

</div>
</div>
<a id="ae3a51dbe990dae1370afe39a65103527" name="ae3a51dbe990dae1370afe39a65103527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a51dbe990dae1370afe39a65103527">&#9670;&nbsp;</a></span>Image() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af92e6ec5a7b76f66671d14480906aef0" name="af92e6ec5a7b76f66671d14480906aef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92e6ec5a7b76f66671d14480906aef0">&#9670;&nbsp;</a></span>Image() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor and assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>After the operation img is valid only for destructing and assignment; all other operations have undefined behavior. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14b96e088ce9f8d72f3c71663b376476" name="a14b96e088ce9f8d72f3c71663b376476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b96e088ce9f8d72f3c71663b376476">&#9670;&nbsp;</a></span>Image() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a>&#160;</td>
          <td class="paramname"><em>valueEnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified. </p>
<p >If the pixel type is a scalar or a label pixel type, then the number of components must be specified as 0 or 1.</p>
<p >If the pixel type is a vector pixel type, then the number of components defaults to the image dimension, unless the numberOfComponents is explicitly specified.</p>
<p >Unlike the standard convention for Dimensional Vectors the size parameter must be the exact dimension requesting. That is, it must be of length 2 of a 2D image, 3 for a 3D image and 4 for a 4D image. </p>

</div>
</div>
<a id="a619f5f36459b477581b3d7f0c99d1f9c" name="a619f5f36459b477581b3d7f0c99d1f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619f5f36459b477581b3d7f0c99d1f9c">&#9670;&nbsp;</a></span>Image() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a>&#160;</td>
          <td class="paramname"><em>valueEnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified. </p>
<p >If the pixel type is a scalar or a label pixel type, then the number of components must be specified as 0 or 1.</p>
<p >If the pixel type is a vector pixel type, then the number of components defaults to the image dimension, unless the numberOfComponents is explicitly specified.</p>
<p >Unlike the standard convention for Dimensional Vectors the size parameter must be the exact dimension requesting. That is, it must be of length 2 of a 2D image, 3 for a 3D image and 4 for a 4D image. </p>

</div>
</div>
<a id="affc77be35235acbc1b67e60e7670194c" name="affc77be35235acbc1b67e60e7670194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc77be35235acbc1b67e60e7670194c">&#9670;&nbsp;</a></span>Image() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a>&#160;</td>
          <td class="paramname"><em>valueEnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberOfComponents</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified. </p>
<p >If the pixel type is a scalar or a label pixel type, then the number of components must be specified as 0 or 1.</p>
<p >If the pixel type is a vector pixel type, then the number of components defaults to the image dimension, unless the numberOfComponents is explicitly specified.</p>
<p >Unlike the standard convention for Dimensional Vectors the size parameter must be the exact dimension requesting. That is, it must be of length 2 of a 2D image, 3 for a 3D image and 4 for a 4D image. </p>

</div>
</div>
<a id="a1b10a5a2f14a9bec516ff47bcba96761" name="a1b10a5a2f14a9bec516ff47bcba96761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b10a5a2f14a9bec516ff47bcba96761">&#9670;&nbsp;</a></span>Image() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>&lt; TImageType &gt;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image. </p>
<p >The SimpleITK image will add a reference to the underlying the ITK image and hold a pointer to the image. If the image is manipulated directly from the ITK interface, SimpleITK may be unaware of it, and may cause complication related to aliasing and SimpleITK copy on write policy.</p>
<p >If simpleITK does not support the image type, a compile-time error or assertion will fail.</p>
<p >The ITK image must be fully buffered, and must have a zero starting index for the Buffered/Largest regions. </p>

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00141">141</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

</div>
</div>
<a id="a135e55d13e3baf01d3cd906d40558605" name="a135e55d13e3baf01d3cd906d40558605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135e55d13e3baf01d3cd906d40558605">&#9670;&nbsp;</a></span>Image() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">TImageType *&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image. </p>
<p >The SimpleITK image will add a reference to the underlying the ITK image and hold a pointer to the image. If the image is manipulated directly from the ITK interface, SimpleITK may be unaware of it, and may cause complication related to aliasing and SimpleITK copy on write policy.</p>
<p >If simpleITK does not support the image type, a compile-time error or assertion will fail.</p>
<p >The ITK image must be fully buffered, and must have a zero starting index for the Buffered/Largest regions. </p>

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00146">146</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">References <a class="el" href="sitkPixelIDValues_8h_source.html#l00091">itk::simple::sitkUnknown</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1cd9b3cdfa9e9159f48cf84ef4461d55" name="a1cd9b3cdfa9e9159f48cf84ef4461d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd9b3cdfa9e9159f48cf84ef4461d55">&#9670;&nbsp;</a></span>Allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::Allocate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a>&#160;</td>
          <td class="paramname"><em>valueEnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberOfComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods called by the constructor to allocate and initialize an image. </p>
<p >This method internally utilizes the member function factory to dispatch to methods instantiated on the image of the pixel ID </p>

</div>
</div>
<a id="a2a4a368b62eaf8d8e86bc351e7e25c1e" name="a2a4a368b62eaf8d8e86bc351e7e25c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4a368b62eaf8d8e86bc351e7e25c1e">&#9670;&nbsp;</a></span>AllocateInternal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TImageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structitk_1_1simple_1_1IsBasic.html">IsBasic</a>&lt; TImageType &gt;::Value &gt;::type itk::simple::Image::AllocateInternal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberOfComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatched methods for allocating images. </p>
<p >The enable if idiom is used here to enable different methods for different pixel/image types. </p>

</div>
</div>
<a id="acc385a1c1ce92435adf1e7400d69f227" name="acc385a1c1ce92435adf1e7400d69f227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc385a1c1ce92435adf1e7400d69f227">&#9670;&nbsp;</a></span>AllocateInternal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TImageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structitk_1_1simple_1_1IsVector.html">IsVector</a>&lt; TImageType &gt;::Value &gt;::type itk::simple::Image::AllocateInternal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberOfComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatched methods for allocating images. </p>
<p >The enable if idiom is used here to enable different methods for different pixel/image types. </p>

</div>
</div>
<a id="aebf9d4ad3e18aeff822af3589005b3de" name="aebf9d4ad3e18aeff822af3589005b3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf9d4ad3e18aeff822af3589005b3de">&#9670;&nbsp;</a></span>AllocateInternal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TImageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structitk_1_1simple_1_1IsLabel.html">IsLabel</a>&lt; TImageType &gt;::Value &gt;::type itk::simple::Image::AllocateInternal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberOfComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatched methods for allocating images. </p>
<p >The enable if idiom is used here to enable different methods for different pixel/image types. </p>

</div>
</div>
<a id="a21171308dcd275a9c80891dac6ca1cc7" name="a21171308dcd275a9c80891dac6ca1cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21171308dcd275a9c80891dac6ca1cc7">&#9670;&nbsp;</a></span>ConditionalInternalInitialization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VPixelIDValue, typename TImageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; TImageType, void &gt;::value &gt;::type itk::simple::Image::ConditionalInternalInitialization </td>
          <td>(</td>
          <td class="paramtype">TImageType *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Dispatched from the InternalInitialization method. The "enable-if" idiom is used here for method overloading. The second method is for non-instantiated image, which turn into a void pointer for the parameter. However, this second method should never be executed. </p>

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00556">556</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

</div>
</div>
<a id="aee7565c1e6714813f611d0bc8cdca97b" name="aee7565c1e6714813f611d0bc8cdca97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7565c1e6714813f611d0bc8cdca97b">&#9670;&nbsp;</a></span>ConditionalInternalInitialization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VPixelIDValue, typename TImageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt; TImageType, void &gt;::value &gt;::type itk::simple::Image::ConditionalInternalInitialization </td>
          <td>(</td>
          <td class="paramtype">TImageType *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Dispatched from the InternalInitialization method. The "enable-if" idiom is used here for method overloading. The second method is for non-instantiated image, which turn into a void pointer for the parameter. However, this second method should never be executed. </p>

</div>
</div>
<a id="afa8a4757400c414e809d1767ee616bd0" name="afa8a4757400c414e809d1767ee616bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a4757400c414e809d1767ee616bd0">&#9670;&nbsp;</a></span>CopyInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::CopyInformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy common meta-data from an image to this one. </p>
<p >Copies the Origin, Spacing, and Direction from the source image to this image. The meta-data dictionary is <b>not</b> copied.</p>
<p >It is required for the source <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a>'s dimension and size to match, this image's attributes, otherwise an exception will be generated. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#a32">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="af5c224f1f5173836258dbb983341a2f9" name="af5c224f1f5173836258dbb983341a2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c224f1f5173836258dbb983341a2f9">&#9670;&nbsp;</a></span>EraseMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::EraseMetaData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry from the meta-data dictionary. </p>
<p >Returns true, when the value exists in the dictionary and is removed, false otherwise. </p>

</div>
</div>
<a id="a393912859bda381a8b7b0ec79cfce4a1" name="a393912859bda381a8b7b0ec79cfce4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393912859bda381a8b7b0ec79cfce4a1">&#9670;&nbsp;</a></span>EvaluateAtContinuousIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::EvaluateAtContinuousIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a>&#160;</td>
          <td class="paramname"><em>interp</em> = <code><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate pixel value at a continuous index. </p>
<p >This method is not supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classLabel.html">Label</a> pixel types.</p>
<p >The valid range of continuous index is [-0.5, size-0.5] for each dimension. An exception is thrown if index is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The continuous index must be at least the length of the image dimension. </td></tr>
    <tr><td class="paramname">interp</td><td>The interpolation type to use, only sitkNearest and sitkLinear are supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All supported pixel types are returned as an array, where complex numbers are returned with the real followed by the complex component. </dd></dl>

</div>
</div>
<a id="aa2f96579d0f3da2d1a3b48d4e1037fbc" name="aa2f96579d0f3da2d1a3b48d4e1037fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f96579d0f3da2d1a3b48d4e1037fbc">&#9670;&nbsp;</a></span>EvaluateAtPhysicalPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::EvaluateAtPhysicalPoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a>&#160;</td>
          <td class="paramname"><em>interp</em> = <code><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Interpolate pixel value at a physical point.</p>
<p >This method is not supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classLabel.html">Label</a> pixel types.</p>
<p >An exception is thrown if the point is out of the defined region for the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The physical point at which the interpolation is computed. </td></tr>
    <tr><td class="paramname">interp</td><td>The interpolation type to use, only sitkNearest and sitkLinear are supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All supported pixel types are returned as an array, where complex numbers are returned with the real followed by the complex component. </dd></dl>

</div>
</div>
<a id="ab7f6ed5fff8ee5d371e6a3671d0cae6a" name="ab7f6ed5fff8ee5d371e6a3671d0cae6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f6ed5fff8ee5d371e6a3671d0cae6a">&#9670;&nbsp;</a></span>GetBufferAsDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * itk::simple::Image::GetBufferAsDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
<div class="ttc" id="anamespaceitk_html_a7f475fc7c9afc4fd9e2564f00149e9e7"><div class="ttname"><a href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a></div><div class="ttdeci">std::uint8_t uint8_t</div></div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a12ad1cd0da557e6bdadacd027d5e95c5" name="a12ad1cd0da557e6bdadacd027d5e95c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ad1cd0da557e6bdadacd027d5e95c5">&#9670;&nbsp;</a></span>GetBufferAsDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * itk::simple::Image::GetBufferAsDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ad896f3be099548ad24a160aa1a4ed357" name="ad896f3be099548ad24a160aa1a4ed357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad896f3be099548ad24a160aa1a4ed357">&#9670;&nbsp;</a></span>GetBufferAsFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * itk::simple::Image::GetBufferAsFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ab903a0f7917525347ed46d3d658e057d" name="ab903a0f7917525347ed46d3d658e057d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab903a0f7917525347ed46d3d658e057d">&#9670;&nbsp;</a></span>GetBufferAsFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float * itk::simple::Image::GetBufferAsFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a69f6a12886842f236958f8b3e89833c7" name="a69f6a12886842f236958f8b3e89833c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f6a12886842f236958f8b3e89833c7">&#9670;&nbsp;</a></span>GetBufferAsInt16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> * itk::simple::Image::GetBufferAsInt16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aa805efe6118819d5d2e41fdd2dd5f57d" name="aa805efe6118819d5d2e41fdd2dd5f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa805efe6118819d5d2e41fdd2dd5f57d">&#9670;&nbsp;</a></span>GetBufferAsInt16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> * itk::simple::Image::GetBufferAsInt16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a7ce813ee554356d8153701bebca63981" name="a7ce813ee554356d8153701bebca63981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce813ee554356d8153701bebca63981">&#9670;&nbsp;</a></span>GetBufferAsInt32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> * itk::simple::Image::GetBufferAsInt32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aae7d8fe774ea0535c2dbe6001a129e40" name="aae7d8fe774ea0535c2dbe6001a129e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7d8fe774ea0535c2dbe6001a129e40">&#9670;&nbsp;</a></span>GetBufferAsInt32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> * itk::simple::Image::GetBufferAsInt32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a14d1ac71dc6d45175ce08c3ae2b12539" name="a14d1ac71dc6d45175ce08c3ae2b12539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d1ac71dc6d45175ce08c3ae2b12539">&#9670;&nbsp;</a></span>GetBufferAsInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> * itk::simple::Image::GetBufferAsInt64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a577e6c1b579b0dd626a75c2d87086b06" name="a577e6c1b579b0dd626a75c2d87086b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577e6c1b579b0dd626a75c2d87086b06">&#9670;&nbsp;</a></span>GetBufferAsInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> * itk::simple::Image::GetBufferAsInt64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aa638d156039b08584904cda2e20157c1" name="aa638d156039b08584904cda2e20157c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa638d156039b08584904cda2e20157c1">&#9670;&nbsp;</a></span>GetBufferAsInt8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> * itk::simple::Image::GetBufferAsInt8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a69898006932ab663c6d1ce6775367821" name="a69898006932ab663c6d1ce6775367821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69898006932ab663c6d1ce6775367821">&#9670;&nbsp;</a></span>GetBufferAsInt8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> * itk::simple::Image::GetBufferAsInt8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8bfa9b811d8cd281dae9e207dbf4c192" name="a8bfa9b811d8cd281dae9e207dbf4c192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfa9b811d8cd281dae9e207dbf4c192">&#9670;&nbsp;</a></span>GetBufferAsUInt16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> * itk::simple::Image::GetBufferAsUInt16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ad3de1a5a1ec46d65f23f985abf37b938" name="ad3de1a5a1ec46d65f23f985abf37b938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3de1a5a1ec46d65f23f985abf37b938">&#9670;&nbsp;</a></span>GetBufferAsUInt16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> * itk::simple::Image::GetBufferAsUInt16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1b7c7fff9e735d24c0a4dbe244ee92f6" name="a1b7c7fff9e735d24c0a4dbe244ee92f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7c7fff9e735d24c0a4dbe244ee92f6">&#9670;&nbsp;</a></span>GetBufferAsUInt32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> * itk::simple::Image::GetBufferAsUInt32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aebe46fa62d720c617997736d91ca96ca" name="aebe46fa62d720c617997736d91ca96ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe46fa62d720c617997736d91ca96ca">&#9670;&nbsp;</a></span>GetBufferAsUInt32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> * itk::simple::Image::GetBufferAsUInt32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6049da4ed7956e16faf093ec63778389" name="a6049da4ed7956e16faf093ec63778389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6049da4ed7956e16faf093ec63778389">&#9670;&nbsp;</a></span>GetBufferAsUInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> * itk::simple::Image::GetBufferAsUInt64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ac2a79f8ee1d6d1c118baeab9708f80e1" name="ac2a79f8ee1d6d1c118baeab9708f80e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a79f8ee1d6d1c118baeab9708f80e1">&#9670;&nbsp;</a></span>GetBufferAsUInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> * itk::simple::Image::GetBufferAsUInt64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a9b011a5e138e90d1375955ba271533a8" name="a9b011a5e138e90d1375955ba271533a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b011a5e138e90d1375955ba271533a8">&#9670;&nbsp;</a></span>GetBufferAsUInt8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> * itk::simple::Image::GetBufferAsUInt8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="BufferImportExport_8cxx-example.html#a11">BufferImportExport.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="a2b1f0a6dc3bfd68cc3c6c400d23ef23c" name="a2b1f0a6dc3bfd68cc3c6c400d23ef23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1f0a6dc3bfd68cc3c6c400d23ef23c">&#9670;&nbsp;</a></span>GetBufferAsUInt8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> * itk::simple::Image::GetBufferAsUInt8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a827ddb6ba0b3e4e351802ce3e65c23e1" name="a827ddb6ba0b3e4e351802ce3e65c23e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827ddb6ba0b3e4e351802ce3e65c23e1">&#9670;&nbsp;</a></span>GetBufferAsVoid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * itk::simple::Image::GetBufferAsVoid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aabd4b5ac2632c7dcc33b971229a51be6" name="aabd4b5ac2632c7dcc33b971229a51be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd4b5ac2632c7dcc33b971229a51be6">&#9670;&nbsp;</a></span>GetBufferAsVoid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * itk::simple::Image::GetBufferAsVoid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line"><a class="code hl_typedefRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p >The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p ><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p >The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a0e9d6f84e457f7f6e59665c26a02cd4e" name="a0e9d6f84e457f7f6e59665c26a02cd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9d6f84e457f7f6e59665c26a02cd4e">&#9670;&nbsp;</a></span>GetDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in the third dimension or 0 if the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is only 2D </p>

</div>
</div>
<a id="a43163c72ca1a49abf615b3dc71e01a36" name="a43163c72ca1a49abf615b3dc71e01a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43163c72ca1a49abf615b3dc71e01a36">&#9670;&nbsp;</a></span>GetDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of physical dimensions.</p>
<p >Only the spatial dimensions are considered here. These are the dimensions the origin, spacing and direction cosine matrix are applicable to. This does not include the pixels' vector index as a dimension. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ITKIntegration_2ITKIntegration_8cxx-example.html#a8">ITKIntegration/ITKIntegration.cxx</a>, <a class="el" href="ImageRegistrationMethod1_2ImageRegistrationMethod1_8cxx-example.html#a10">ImageRegistrationMethod1/ImageRegistrationMethod1.cxx</a>, <a class="el" href="ImageRegistrationMethod2_2ImageRegistrationMethod2_8cxx-example.html#a13">ImageRegistrationMethod2/ImageRegistrationMethod2.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline1_2ImageRegistrationMethodBSpline1_8cxx-example.html#a6">ImageRegistrationMethodBSpline1/ImageRegistrationMethodBSpline1.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline3_2ImageRegistrationMethodBSpline3_8cxx-example.html#a7">ImageRegistrationMethodBSpline3/ImageRegistrationMethodBSpline3.cxx</a>, <a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#a9">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>, <a class="el" href="N4BiasFieldCorrection_2N4BiasFieldCorrection_8cxx-example.html#a5">N4BiasFieldCorrection/N4BiasFieldCorrection.cxx</a>, and <a class="el" href="SliceBySliceDecorator_2SliceBySliceDecorator_8cxx-example.html#a2">SliceBySliceDecorator/SliceBySliceDecorator.cxx</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="sitkProcessObject_8h_source.html#l00342">itk::simple::ProcessObject::CastImageToITK()</a>.</p>

</div>
</div>
<a id="a7bd35f108a2df5c966285405af409548" name="a7bd35f108a2df5c966285405af409548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd35f108a2df5c966285405af409548">&#9670;&nbsp;</a></span>GetDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Get the Direction. </p>
<p >Internally, the Direction is represented by a matrix 2x2 for a 2D and 3x3 for a 3D image. The matrix is passed as a 1D array in row-major form. </p>

</div>
</div>
<a id="a88a9572d84ae73623652bdc1ecb7cf2d" name="a88a9572d84ae73623652bdc1ecb7cf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a9572d84ae73623652bdc1ecb7cf2d">&#9670;&nbsp;</a></span>GetHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in the second dimension </p>

</div>
</div>
<a id="a600c5cd0fe2345b2d0a2e09997dfa1d6" name="a600c5cd0fe2345b2d0a2e09997dfa1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600c5cd0fe2345b2d0a2e09997dfa1d6">&#9670;&nbsp;</a></span>GetITKBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> * itk::simple::Image::GetITKBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get access to internal ITK data object.</p>
<p >The return value should immediately be assigned to as <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>.</p>
<p >In many cases the value may need to be dynamically casted to the actual image type. The <a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">GetPixelIDValue()</a> method should return an PixelID which identifies the image type which the <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">DataObject</a> points to.</p>
<p >If this object has been moved, then nullptr is returned. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ITKIntegration_2ITKIntegration_8cxx-example.html#a13">ITKIntegration/ITKIntegration.cxx</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="sitkProcessObject_8h_source.html#l00342">itk::simple::ProcessObject::CastImageToITK()</a>.</p>

</div>
</div>
<a id="a590b6dd151816ef8a4b549e95ed1bf57" name="a590b6dd151816ef8a4b549e95ed1bf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590b6dd151816ef8a4b549e95ed1bf57">&#9670;&nbsp;</a></span>GetITKBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> * itk::simple::Image::GetITKBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get access to internal ITK data object.</p>
<p >The return value should immediately be assigned to as <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>.</p>
<p >In many cases the value may need to be dynamically casted to the actual image type. The <a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">GetPixelIDValue()</a> method should return an PixelID which identifies the image type which the <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">DataObject</a> points to.</p>
<p >If this object has been moved, then nullptr is returned. </p>

</div>
</div>
<a id="a43df17945f303feb16b4accf1b684515" name="a43df17945f303feb16b4accf1b684515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43df17945f303feb16b4accf1b684515">&#9670;&nbsp;</a></span>GetMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string itk::simple::Image::GetMetaData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a meta-data dictionary entry as a string. </p>
<p >If the key is not in the dictionary then an exception is thrown.</p>
<p >string types in the dictionary are returned as their native strings. Other types are printed to string before returning. </p>

</div>
</div>
<a id="a4cf9bbdb75a90784da8012286a8692eb" name="a4cf9bbdb75a90784da8012286a8692eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf9bbdb75a90784da8012286a8692eb">&#9670;&nbsp;</a></span>GetMetaDataKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; itk::simple::Image::GetMetaDataKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a vector of keys in from the meta-data dictionary </p>
<p >Returns a vector of keys to the key/value entries in the image's meta-data dictionary. Iterate through with these keys to get the values. </p>

</div>
</div>
<a id="abb8b4188222fc781607ab26c69fc5423" name="abb8b4188222fc781607ab26c69fc5423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b4188222fc781607ab26c69fc5423">&#9670;&nbsp;</a></span>GetNumberOfComponentsPerPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetNumberOfComponentsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of components for each pixel. </p>
<p >For images with scalar or complex pixel types this method returns one. For images with a vector pixel type the method returns the number of vector components per pixel. </p>

</div>
</div>
<a id="a584912065b5cc03923319b15bd9fc16e" name="a584912065b5cc03923319b15bd9fc16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584912065b5cc03923319b15bd9fc16e">&#9670;&nbsp;</a></span>GetNumberOfPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> itk::simple::Image::GetNumberOfPixels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of pixels in the image. </p>
<p >To calculate the total number of values stored continuously for the image's buffer, the NumberOfPixels should be multiplied by NumberOfComponentsPerPixel in order to account for multiple component images. </p>

</div>
</div>
<a id="a622920d3325ee831eba2ddad89d7eb3d" name="a622920d3325ee831eba2ddad89d7eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622920d3325ee831eba2ddad89d7eb3d">&#9670;&nbsp;</a></span>GetOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get/Set the Origin in physical space </p>

</div>
</div>
<a id="adb89bcefd90119d4b55407be5b30cc25" name="adb89bcefd90119d4b55407be5b30cc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb89bcefd90119d4b55407be5b30cc25">&#9670;&nbsp;</a></span>GetPixelAsComplexFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; float &gt; itk::simple::Image::GetPixelAsComplexFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1889da3071e6aa7daaa673db7be89266" name="a1889da3071e6aa7daaa673db7be89266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1889da3071e6aa7daaa673db7be89266">&#9670;&nbsp;</a></span>GetPixelAsComplexFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; itk::simple::Image::GetPixelAsComplexFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a958fc359792de9213e87dc20f8fa400d" name="a958fc359792de9213e87dc20f8fa400d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958fc359792de9213e87dc20f8fa400d">&#9670;&nbsp;</a></span>GetPixelAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double itk::simple::Image::GetPixelAsDouble </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6e04ac6dc1e3a789f6b5f3fde6a704ad" name="a6e04ac6dc1e3a789f6b5f3fde6a704ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e04ac6dc1e3a789f6b5f3fde6a704ad">&#9670;&nbsp;</a></span>GetPixelAsFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float itk::simple::Image::GetPixelAsFloat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ab36e43923c39880321b04eda1436c4e2" name="ab36e43923c39880321b04eda1436c4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36e43923c39880321b04eda1436c4e2">&#9670;&nbsp;</a></span>GetPixelAsInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> itk::simple::Image::GetPixelAsInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="abd014ee850c3b779b242577c795d568d" name="abd014ee850c3b779b242577c795d568d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd014ee850c3b779b242577c795d568d">&#9670;&nbsp;</a></span>GetPixelAsInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> itk::simple::Image::GetPixelAsInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae1955c632dd4c04be1573d4dbadfcdec" name="ae1955c632dd4c04be1573d4dbadfcdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1955c632dd4c04be1573d4dbadfcdec">&#9670;&nbsp;</a></span>GetPixelAsInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> itk::simple::Image::GetPixelAsInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ad0c57fd2e652cef42678df6721ee91ef" name="ad0c57fd2e652cef42678df6721ee91ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c57fd2e652cef42678df6721ee91ef">&#9670;&nbsp;</a></span>GetPixelAsInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> itk::simple::Image::GetPixelAsInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a7bda2c933c0fc074041619f292d53b3f" name="a7bda2c933c0fc074041619f292d53b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bda2c933c0fc074041619f292d53b3f">&#9670;&nbsp;</a></span>GetPixelAsUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> itk::simple::Image::GetPixelAsUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a54e68cff0ddbee6c0516d2f5436df4d3" name="a54e68cff0ddbee6c0516d2f5436df4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e68cff0ddbee6c0516d2f5436df4d3">&#9670;&nbsp;</a></span>GetPixelAsUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> itk::simple::Image::GetPixelAsUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aeef2dd54b1b62e61e92026b92a8e8dfa" name="aeef2dd54b1b62e61e92026b92a8e8dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef2dd54b1b62e61e92026b92a8e8dfa">&#9670;&nbsp;</a></span>GetPixelAsUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> itk::simple::Image::GetPixelAsUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a9c1e93337f99f36e695921bb1e699126" name="a9c1e93337f99f36e695921bb1e699126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1e93337f99f36e695921bb1e699126">&#9670;&nbsp;</a></span>GetPixelAsUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> itk::simple::Image::GetPixelAsUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a26348f6e3a42a837a455d611de8485e1" name="a26348f6e3a42a837a455d611de8485e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26348f6e3a42a837a455d611de8485e1">&#9670;&nbsp;</a></span>GetPixelAsVectorFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; itk::simple::Image::GetPixelAsVectorFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aab7c9ed9277ffd2690aecc000e974c07" name="aab7c9ed9277ffd2690aecc000e974c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c9ed9277ffd2690aecc000e974c07">&#9670;&nbsp;</a></span>GetPixelAsVectorFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetPixelAsVectorFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a115dd3ac39fe400bc5015a6f04231061" name="a115dd3ac39fe400bc5015a6f04231061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115dd3ac39fe400bc5015a6f04231061">&#9670;&nbsp;</a></span>GetPixelAsVectorInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> &gt; itk::simple::Image::GetPixelAsVectorInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6eaf8347c90dcd454e2f2d87c3b9078c" name="a6eaf8347c90dcd454e2f2d87c3b9078c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaf8347c90dcd454e2f2d87c3b9078c">&#9670;&nbsp;</a></span>GetPixelAsVectorInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> &gt; itk::simple::Image::GetPixelAsVectorInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a0ecd82663427b6ee5736ebc1dfedf51b" name="a0ecd82663427b6ee5736ebc1dfedf51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecd82663427b6ee5736ebc1dfedf51b">&#9670;&nbsp;</a></span>GetPixelAsVectorInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt; itk::simple::Image::GetPixelAsVectorInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8da3f19798a0c30488ab412e3d707505" name="a8da3f19798a0c30488ab412e3d707505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da3f19798a0c30488ab412e3d707505">&#9670;&nbsp;</a></span>GetPixelAsVectorInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> &gt; itk::simple::Image::GetPixelAsVectorInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae280918c7fa7fa0f517442d82a1ca631" name="ae280918c7fa7fa0f517442d82a1ca631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae280918c7fa7fa0f517442d82a1ca631">&#9670;&nbsp;</a></span>GetPixelAsVectorUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> &gt; itk::simple::Image::GetPixelAsVectorUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aacc761996e1b65903d7f003824da793f" name="aacc761996e1b65903d7f003824da793f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc761996e1b65903d7f003824da793f">&#9670;&nbsp;</a></span>GetPixelAsVectorUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; itk::simple::Image::GetPixelAsVectorUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="affa93e9578bcf1f93e6e4d0c9b85949e" name="affa93e9578bcf1f93e6e4d0c9b85949e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa93e9578bcf1f93e6e4d0c9b85949e">&#9670;&nbsp;</a></span>GetPixelAsVectorUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> &gt; itk::simple::Image::GetPixelAsVectorUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="acdd696c8b0f218ea75c97c86db5983d2" name="acdd696c8b0f218ea75c97c86db5983d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd696c8b0f218ea75c97c86db5983d2">&#9670;&nbsp;</a></span>GetPixelAsVectorUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> &gt; itk::simple::Image::GetPixelAsVectorUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p >Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a780923bec6a71b14be35d81069f343f6" name="a780923bec6a71b14be35d81069f343f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780923bec6a71b14be35d81069f343f6">&#9670;&nbsp;</a></span>GetPixelID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> itk::simple::Image::GetPixelID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the pixel type</p>
<p >The pixel type is set at construction type and can not be manually changed, unless by assignment. The value may be -1 or "Unknown". </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="BufferImportExport_8cxx-example.html#a9">BufferImportExport.cxx</a>, <a class="el" href="DemonsRegistration2_2DemonsRegistration2_8cxx-example.html#a6">DemonsRegistration2/DemonsRegistration2.cxx</a>, <a class="el" href="FilterProgressReporting_2FilterProgressReporting_8cxx-example.html#a14">FilterProgressReporting/FilterProgressReporting.cxx</a>, <a class="el" href="SimpleGaussian_2SimpleGaussian_8cxx-example.html#a9">SimpleGaussian/SimpleGaussian.cxx</a>, and <a class="el" href="SimpleGaussianFunctional_8cxx-example.html#a2">SimpleGaussianFunctional.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="ad195963d0b257560819b833b9cfe18d6" name="ad195963d0b257560819b833b9cfe18d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad195963d0b257560819b833b9cfe18d6">&#9670;&nbsp;</a></span>GetPixelIDTypeAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string itk::simple::Image::GetPixelIDTypeAsString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the pixel type as a human readable string value. </p>

<p class="reference">Referenced by <a class="el" href="sitkProcessObject_8h_source.html#l00342">itk::simple::ProcessObject::CastImageToITK()</a>.</p>

</div>
</div>
<a id="a3c27e845c3327ae8cf133db1750fd18b" name="a3c27e845c3327ae8cf133db1750fd18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c27e845c3327ae8cf133db1750fd18b">&#9670;&nbsp;</a></span>GetPixelIDValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceitk_1_1simple.html#ae47036246a9a1312411ce2fc6d296d1d">PixelIDValueType</a> itk::simple::Image::GetPixelIDValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade45738b2c906a51f23532aa972f6169" name="ade45738b2c906a51f23532aa972f6169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade45738b2c906a51f23532aa972f6169">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; itk::simple::Image::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in each dimension as a std::vector. The size of the vector is equal to the number of dimensions for the image. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomSeriesReader_2DicomSeriesReader_8cxx-example.html#a5">DicomSeriesReader/DicomSeriesReader.cxx</a>, <a class="el" href="ImageIOSelection_2ImageIOSelection_8cxx-example.html#a7">ImageIOSelection/ImageIOSelection.cxx</a>, <a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#a30">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>, and <a class="el" href="SliceBySliceDecorator_2SliceBySliceDecorator_8cxx-example.html#a1">SliceBySliceDecorator/SliceBySliceDecorator.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="af4705e6e3ad0dcec4a8230462af81c19" name="af4705e6e3ad0dcec4a8230462af81c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4705e6e3ad0dcec4a8230462af81c19">&#9670;&nbsp;</a></span>GetSizeOfPixelComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetSizeOfPixelComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes per component of a pixel. </p>
<p >Returns the <code>sizeof</code> the pixel component type. </p>

</div>
</div>
<a id="a669907e56274c6ca2838be3bf4a5ac9f" name="a669907e56274c6ca2838be3bf4a5ac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669907e56274c6ca2838be3bf4a5ac9f">&#9670;&nbsp;</a></span>GetSpacing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetSpacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get/Set the Spacing of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> as an std::vector .</p>
<p >The spacing describes the physical size of each pixel. The length of the vector is equal to the dimension of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a>. </p>

</div>
</div>
<a id="af7b9ca4a6cd1a0c77e8c5c713e447b3a" name="af7b9ca4a6cd1a0c77e8c5c713e447b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b9ca4a6cd1a0c77e8c5c713e447b3a">&#9670;&nbsp;</a></span>GetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in the first dimension </p>

</div>
</div>
<a id="a38b869a842f2e7aeb75fbd0a84046cca" name="a38b869a842f2e7aeb75fbd0a84046cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b869a842f2e7aeb75fbd0a84046cca">&#9670;&nbsp;</a></span>HasMetaDataKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::HasMetaDataKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the meta-data dictionary for the existence of a key. </p>

</div>
</div>
<a id="a6ad2b5c0e5f9d94d953e8e4469bbfa1e" name="a6ad2b5c0e5f9d94d953e8e4469bbfa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad2b5c0e5f9d94d953e8e4469bbfa1e">&#9670;&nbsp;</a></span>InternalInitialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VPixelIDValue, unsigned int VImageDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::InternalInitialization </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structitk_1_1simple_1_1PixelIDToImageType.html">PixelIDToImageType</a>&lt; typename typelist::TypeAt&lt; <a class="el" href="namespaceitk_1_1simple.html#aca9bcea069d3753ee0303e2d0b9270af">InstantiatedPixelIDTypeList</a>, VPixelIDValue &gt;::Result, VImageDimension &gt;::ImageType *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method called by certain constructors to convert ITK images into simpleITK ones.</p>
<p >This is the single method which needs to be explicitly instantiated to separate the internal ITK and Pimple image from the external SimpleITK interface. Template parameters have been chosen carefully to flexibly enable this. </p>

</div>
</div>
<a id="aec5b1f66e3812a286b3e9f4ac8ed976f" name="aec5b1f66e3812a286b3e9f4ac8ed976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5b1f66e3812a286b3e9f4ac8ed976f">&#9670;&nbsp;</a></span>IsUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::IsUnique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if no other SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> object refers to the same internal data structure. </p>

</div>
</div>
<a id="ab5066b75d324db414df1a34c4065d1c9" name="ab5066b75d324db414df1a34c4065d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5066b75d324db414df1a34c4065d1c9">&#9670;&nbsp;</a></span>MakeUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::MakeUnique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs actually coping if needed to make object unique. </p>
<p >The <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class by default performs lazy coping and assignment. This method make sure that coping actually happens to the <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Image.html">itk::Image</a> pointed to is only pointed to by this object. </p>

</div>
</div>
<a id="a544257ed6b37d939c081af1c18753b2c" name="a544257ed6b37d939c081af1c18753b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544257ed6b37d939c081af1c18753b2c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp; itk::simple::Image::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd7c186de418cc97050e3ced622cf8c2" name="abd7c186de418cc97050e3ced622cf8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7c186de418cc97050e3ced622cf8c2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp; itk::simple::Image::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04d6c8b3777b454b6da1ee1d3e7ed56f" name="a04d6c8b3777b454b6da1ee1d3e7ed56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d6c8b3777b454b6da1ee1d3e7ed56f">&#9670;&nbsp;</a></span>SetDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetDirection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Get the Direction. </p>
<p >Internally, the Direction is represented by a matrix 2x2 for a 2D and 3x3 for a 3D image. The matrix is passed as a 1D array in row-major form. </p>

</div>
</div>
<a id="a1663c39bf013511f30a632a6b4290d83" name="a1663c39bf013511f30a632a6b4290d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1663c39bf013511f30a632a6b4290d83">&#9670;&nbsp;</a></span>SetMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetMetaData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an entry in the meta-data dictionary. </p>
<p >Replaces or creates an entry in the image's meta-data dictionary. </p>

</div>
</div>
<a id="a9648b61b714ddd980d3b7b78bf5562ed" name="a9648b61b714ddd980d3b7b78bf5562ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9648b61b714ddd980d3b7b78bf5562ed">&#9670;&nbsp;</a></span>SetOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetOrigin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get/Set the Origin in physical space </p>

</div>
</div>
<a id="aff869ab52a6b49bfbb4caa4a8ade6209" name="aff869ab52a6b49bfbb4caa4a8ade6209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff869ab52a6b49bfbb4caa4a8ade6209">&#9670;&nbsp;</a></span>SetPixelAsComplexFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsComplexFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; float &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="adb107c591ef00628fe9b3d3ff8b369ac" name="adb107c591ef00628fe9b3d3ff8b369ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb107c591ef00628fe9b3d3ff8b369ac">&#9670;&nbsp;</a></span>SetPixelAsComplexFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsComplexFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1ba546cc106fc7af755421fa6fe72871" name="a1ba546cc106fc7af755421fa6fe72871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba546cc106fc7af755421fa6fe72871">&#9670;&nbsp;</a></span>SetPixelAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsDouble </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae243d0aa8d3a1f0b5c8a5335d21ae2e5" name="ae243d0aa8d3a1f0b5c8a5335d21ae2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae243d0aa8d3a1f0b5c8a5335d21ae2e5">&#9670;&nbsp;</a></span>SetPixelAsFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsFloat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a75442c64fc1933c088c02ef11be5373a" name="a75442c64fc1933c088c02ef11be5373a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75442c64fc1933c088c02ef11be5373a">&#9670;&nbsp;</a></span>SetPixelAsInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a5b9214c2b5437c831eff5a5ca220439c" name="a5b9214c2b5437c831eff5a5ca220439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9214c2b5437c831eff5a5ca220439c">&#9670;&nbsp;</a></span>SetPixelAsInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a3f2c9ff8b97b2ffd9c8a7b106377a0f8" name="a3f2c9ff8b97b2ffd9c8a7b106377a0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2c9ff8b97b2ffd9c8a7b106377a0f8">&#9670;&nbsp;</a></span>SetPixelAsInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8c01f6319e38f168010c6c597465a146" name="a8c01f6319e38f168010c6c597465a146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c01f6319e38f168010c6c597465a146">&#9670;&nbsp;</a></span>SetPixelAsInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a50743b5a080be742524c461a4f1aa320" name="a50743b5a080be742524c461a4f1aa320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50743b5a080be742524c461a4f1aa320">&#9670;&nbsp;</a></span>SetPixelAsUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a586633efa5fd70f1769a5e2255459264" name="a586633efa5fd70f1769a5e2255459264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586633efa5fd70f1769a5e2255459264">&#9670;&nbsp;</a></span>SetPixelAsUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6088cb5d92145f9aec2f82b4b273dee5" name="a6088cb5d92145f9aec2f82b4b273dee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6088cb5d92145f9aec2f82b4b273dee5">&#9670;&nbsp;</a></span>SetPixelAsUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="abe256cff6ccbcb37f89a61a83fda0763" name="abe256cff6ccbcb37f89a61a83fda0763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe256cff6ccbcb37f89a61a83fda0763">&#9670;&nbsp;</a></span>SetPixelAsUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a862c2f02ce7abc80943e1cbbb75f8954" name="a862c2f02ce7abc80943e1cbbb75f8954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862c2f02ce7abc80943e1cbbb75f8954">&#9670;&nbsp;</a></span>SetPixelAsVectorFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae0326247d1ca5051fba7d1c07b676099" name="ae0326247d1ca5051fba7d1c07b676099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0326247d1ca5051fba7d1c07b676099">&#9670;&nbsp;</a></span>SetPixelAsVectorFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a235e853836366fac8ee98de3d80fb866" name="a235e853836366fac8ee98de3d80fb866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235e853836366fac8ee98de3d80fb866">&#9670;&nbsp;</a></span>SetPixelAsVectorInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a804a48cf878cd977d3cbfb473d4a9726">int16_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8c8b8d47857d714e5c1cc06f0dc78b43" name="a8c8b8d47857d714e5c1cc06f0dc78b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8b8d47857d714e5c1cc06f0dc78b43">&#9670;&nbsp;</a></span>SetPixelAsVectorInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a85d8c6595acabd1db6f3efb06c2a0e01">int32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ab595292b40ced613b36411608f1408a9" name="ab595292b40ced613b36411608f1408a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab595292b40ced613b36411608f1408a9">&#9670;&nbsp;</a></span>SetPixelAsVectorInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a88e10b7b03904ff90b38e9cc92ccf1ef" name="a88e10b7b03904ff90b38e9cc92ccf1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e10b7b03904ff90b38e9cc92ccf1ef">&#9670;&nbsp;</a></span>SetPixelAsVectorInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a6b14e3f4352e39b99aebac484bf686b7">int8_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a7d3627592f3f167e398a3b4b43ab1d91" name="a7d3627592f3f167e398a3b4b43ab1d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3627592f3f167e398a3b4b43ab1d91">&#9670;&nbsp;</a></span>SetPixelAsVectorUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a304ec41581c73245d3208668e3a88aba">uint16_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aeb6ae62b2ba271d90764e03ba3155f3f" name="aeb6ae62b2ba271d90764e03ba3155f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6ae62b2ba271d90764e03ba3155f3f">&#9670;&nbsp;</a></span>SetPixelAsVectorUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aecc04519f671706868e9c642cf1e4dad" name="aecc04519f671706868e9c642cf1e4dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc04519f671706868e9c642cf1e4dad">&#9670;&nbsp;</a></span>SetPixelAsVectorUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aa30d81ac5ef1488088262131ee1cfd52">uint64_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1e53202d40fd48f6d4b9fb55f2ed9c6d" name="a1e53202d40fd48f6d4b9fb55f2ed9c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e53202d40fd48f6d4b9fb55f2ed9c6d">&#9670;&nbsp;</a></span>SetPixelAsVectorUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a109e7e66d7632a8f961fb36698e56e5f">uint32_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#a7f475fc7c9afc4fd9e2564f00149e9e7">uint8_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p >Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="classitk_1_1simple_1_1Image.html#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1simple_1_1Image.html#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1b285752e1a79e123c055dc6fa95a50a" name="a1b285752e1a79e123c055dc6fa95a50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b285752e1a79e123c055dc6fa95a50a">&#9670;&nbsp;</a></span>SetSpacing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetSpacing </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get/Set the Spacing of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> as an std::vector .</p>
<p >The spacing describes the physical size of each pixel. The length of the vector is equal to the dimension of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a>. </p>

</div>
</div>
<a id="a47c9fa1902dae8f984bda1bdeafa4a3c" name="a47c9fa1902dae8f984bda1bdeafa4a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c9fa1902dae8f984bda1bdeafa4a3c">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string itk::simple::Image::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a639da24d8df6d41989447d2ec95cb51d" name="a639da24d8df6d41989447d2ec95cb51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639da24d8df6d41989447d2ec95cb51d">&#9670;&nbsp;</a></span>TransformContinuousIndexToPhysicalPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::TransformContinuousIndexToPhysicalPoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> continuous index to physical point </p>

</div>
</div>
<a id="a87c1a1ecaa5bd379d3132c7e95619aaa" name="a87c1a1ecaa5bd379d3132c7e95619aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c1a1ecaa5bd379d3132c7e95619aaa">&#9670;&nbsp;</a></span>TransformIndexToPhysicalPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::TransformIndexToPhysicalPoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> index to physical point </p>

</div>
</div>
<a id="af2aa3f19b31f54ec9fc2846a29428adb" name="af2aa3f19b31f54ec9fc2846a29428adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2aa3f19b31f54ec9fc2846a29428adb">&#9670;&nbsp;</a></span>TransformPhysicalPointToContinuousIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::TransformPhysicalPointToContinuousIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> physical point to continuous index </p>

</div>
</div>
<a id="a9474e4ded374c8350418fe5329187704" name="a9474e4ded374c8350418fe5329187704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9474e4ded374c8350418fe5329187704">&#9670;&nbsp;</a></span>TransformPhysicalPointToIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="https://www.itk.org/Doxygen/html/namespaceitk.html#aea2aea829b465b971c0a8edeb5d01568">int64_t</a> &gt; itk::simple::Image::TransformPhysicalPointToIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> physical point to index </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a76b5c98046d927e528a449442420a448" name="a76b5c98046d927e528a449442420a448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b5c98046d927e528a449442420a448">&#9670;&nbsp;</a></span>m_PimpleImage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a>* itk::simple::Image::m_PimpleImage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00574">574</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="sitkImage_8h_source.html">sitkImage.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
    Generated on <span id="datetime">unknown</span> for SimpleITK by &#160;
    <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.2 | <a href="https://simpleitk.org/privacy_policy.html">
      Privacy Policy</a>
</small></address>
</body>
</html>
